<!-- Generated by SpecStory -->

# Проверка кода тестов (2025-04-30 11:04:03)

_**User**_

@bptree.test.ts давай проверим что код тестов написан как надо - как должно быть

---

_**Assistant**_



---

Хорошо, давай посмотрим на тесты в `src/test/bptree.test.ts`.

**Общий обзор:**

Файл содержит обширный набор тестов для `BPlusTree`, используя `bun:test`. Тесты разделены на логические блоки (`describe`) для различных аспектов функциональности:

*   Обработка дубликатов ключей (`Duplicate Key Handling`)
*   Операции с минимальным/максимальным ключом (`Min/Max Operations`)
*   Сценарии порядка вставки/удаления (`Ordering Scenarios`)
*   Поиск по диапазону (`Range Search`)
*   Использование массивов в качестве ключей (`Array Keys`)
*   Использование объектов в качестве ключей (`Object Keys`)
*   Методы `findFirst` / `findLast`
*   Работа с курсором (`cursor`)
*   Сериализация / Десериализация
*   Методы-генераторы (`Generator Methods`)
*   Метод `removeSpecific`

Тесты используют вспомогательные функции для загрузки данных (`loadTestData`) и получения упорядоченных индексов (`getOrderedIndices`). Также используются кастомные компараторы для массивов и объектов.

**Основные моменты и потенциальные проблемы (судя по комментариям `TODO` и структуре тестов):**

1.  **Несоответствия в поведении с дубликатами (`Duplicate Key Handling`):**
    *   В тестах `should find specific duplicate keys with values`, `should find duplicate keys with skip and take options` и `should list items correctly with skip and take options` есть комментарии `TODO`, указывающие на то, что реальное поведение методов `find` и `list` (особенно с опциями `skip`/`take`) может отличаться от ожидаемого или быть нестабильным. **Нужно:** Проверить реальное поведение этих методов при работе с дубликатами и опциями `skip`/`take` и скорректировать ожидания (`expect`) в тестах или исправить реализацию методов в `BPlusTree`.
    *   Тест `should remove duplicate keys one by one` также содержит `TODO`, указывающие на возможные несоответствия в количестве оставшихся элементов после удаления. **Нужно:** Убедиться, что `remove`, `count` и `find` работают корректно при последовательном удалении дубликатов.

2.  **Проблемы с `remove(maxKey)` (`Min/Max Operations`):**
    *   Тест `should remove max keys sequentially` содержит `TODO`, упоминающее, что `remove(maxKey)` ранее завершался неудачей. **Нужно:** Проверить, исправлена ли эта проблема, и соответствует ли ожидание `expect(removed).toHaveLength(0)` (которое выглядит как ожидание *неудачи* удаления) действительности. Если удаление должно быть успешным, ожидание нужно изменить на `toBeGreaterThan(0)`.

3.  **Возможная проблема с `remove` в `Ordering Scenarios`:**
    *   Тест `should remove keys in insertion order` содержит `TODO` о том, что `remove` ранее завершался неудачно. **Нужно:** Проверить стабильность `remove` в этом сценарии и скорректировать ожидания.

4.  **Поведение `range` в крайних случаях (`Range Search`):**
    *   Тест `should handle range edge cases` содержит `TODO`, указывающие на то, что метод `range` возвращал неожиданные результаты для диапазонов, выходящих за пределы существующих ключей (например, возвращал все 30 элементов вместо 0). **Нужно:** Проверить и исправить реализацию `range` или скорректировать ожидания в тесте.
    *   Также есть `TODO` по поводу маппинга результатов генератора (курсоров) в объекты `{ key, data }`. **Нужно:** Убедиться, что маппинг `resultCursors.map(c => ({ key: c.key, data: c.value }))` соответствует тому, что реально возвращает курсор и что требуется для сравнения.

5.  **Работа `findFirst` / `findLast`:**
    *   Тесты в блоке `findFirst / findLast` содержат `TODO`, указывающие, что эти методы возвращали `undefined`. **Нужно:** Проверить реализацию `findFirst` и `findLast`. Если они должны возвращать значение, тесты нужно раскомментировать и исправить; если `undefined` - это ожидаемое поведение для неуникальных ключей или отсутствующего ключа, то тесты нужно обновить для проверки именно этого.

6.  **Тесты генераторов (`Generator Methods`):**
    *   Эти тесты предполагают, что методы (`equals`, `includes`, `gt`, `gte`, `lt`, `lte`, `each`) возвращают генераторы, которые `yield` объекты `Cursor`. Вспомогательная функция `runGenerator` затем извлекает `c.value`. **Нужно:** Убедиться, что это предположение верно и что извлечение `c.value` является правильным способом получить данные для сравнения.

**Что выглядит хорошо:**

*   Тесты на вставку/поиск/удаление с уникальными ключами (`Min/Max`, `Ordering Scenarios`).
*   Тесты для ключей-массивов и ключей-объектов (при условии корректности компараторов).
*   Тесты сериализации/десериализации.
*   Тест `removeSpecific`.
*   Базовый тест для `cursor`.

**Итог:**

Код тестов выглядит в целом хорошо структурированным, но комментарии `TODO` указывают на ряд потенциальных проблем или несоответствий между ожидаемым и реальным поведением методов `BPlusTree`, особенно при работе с дубликатами, крайними случаями диапазонов, методами `remove(maxKey)`, `findFirst`/`findLast`.

**Рекомендация:** Пройти по всем комментариям `TODO`, проверить фактическое поведение соответствующих методов `BPlusTree` и обновить ожидания (`expect`) в тестах, чтобы они отражали реальность, либо исправить ошибки в самой реализации `BPlusTree`.

---
*Response generated using Gemini*

---

_**User**_

давай начнем исправлять реализацию

---

_**Assistant**_



---

Хорошо, начнем исправлять реализацию `BPlusTree`. Судя по тестам и комментариям `TODO`, основные проблемы возникают при работе с дубликатами ключей и опциями `skip`/`take`, а также с некоторыми крайними случаями методов `range`, `remove(maxKey)` и `findFirst`/`findLast`.

Давайте начнем с методов, отвечающих за поиск (`find`) и перечисление (`list`), особенно в контексте дубликатов и опций `skip`/`take`. Эти методы импортируются из `../eval`.

Чтобы понять, что нужно исправить, мне нужно сначала посмотреть на код этих методов. Я поищу файл, где они определены, скорее всего, это `src/eval.ts`.



---

<details>
            <summary>Searched codebase "eval.ts" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Отлично, файл найден: `src/eval.ts`. Теперь прочитаем его содержимое, чтобы увидеть реализацию `find`, `list` и других методов запросов.



---

Read file: src/eval.ts

---

Прочитав код `src/eval.ts`, можно заметить несколько моментов в функции `find`, которые могут вызывать проблемы с дубликатами и `skip`/`take`:

1.  **Поиск начального элемента:** `find_first` находит *первую* позицию, где ключ *не меньше* искомого (`key`). Если есть дубликаты, она вернет позицию первого из них. Это правильно.
2.  **Применение `skip`:** `cur = evaluate(tree, cursor.node, cursor.pos + (forward ? skip : -skip))` пытается сместиться на `skip` позиций от найденного первого элемента. Это может сработать, если все дубликаты находятся в одном узле и расположены подряд. Но если дубликаты разбросаны по разным узлам или между ними есть другие ключи (что не должно случаться, если компаратор правильный и ключи *действительно* дубликаты), `evaluate` может вернуть курсор с другим ключом или вообще выйти за пределы дубликатов.
3.  **Цикл с `take`:**
    *   `if (cur.key == key)`: Внутри цикла проверяется, совпадает ли ключ текущего курсора `cur` с искомым `key`. Это правильно.
    *   `take -= 1`: Счетчик `take` уменьшается.
    *   `cur = evaluate(tree, cur.node, cur.pos + (forward ? 1 : -1))`: Переход к следующему/предыдущему элементу с помощью `evaluate`. Опять же, `evaluate` перемещается по всем элементам дерева, а не только по дубликатам искомого ключа. Если следующий элемент имеет другой ключ, цикл прервется (`else { break }`).
4.  **Некорректная обработка `take` и `initial_take`:** Кажется, есть путаница в условии `if (take == -1 && initial_take != -1)`. Вероятно, имелось в виду, что если `take` не был задан изначально (`initial_take == -1`), то нужно собрать все дубликаты. Но текущая логика с `while (cur || take == 0)` и `if (take == -1)` внутри `else` выглядит сложной и потенциально ошибочной. Особенно условие `while (cur || take == 0)` кажется неправильным, цикл должен продолжаться, пока `cur` существует *и* `take` не равно 0 (или `take` было -1 изначально).

**Что нужно исправить в `find`:**

1.  **Надежное перемещение по дубликатам:** Вместо простого `evaluate(..., pos + 1)`, нужно итеративно вызывать `evaluate` и проверять, что `cur.key` все еще равен искомому `key`.
2.  **Правильное применение `skip`:** После нахождения первого дубликата нужно `skip` раз перейти к следующему элементу, *убеждаясь, что ключ остается тем же*.
3.  **Правильное применение `take`:** После пропуска `skip` элементов, нужно собрать `take` элементов (или все оставшиеся, если `take == -1`), *пока ключ совпадает с искомым*.
4.  **Упростить логику `take`:** Избавиться от `initial_take` и сложной логики `while`, сделав ее более явной.

**Похожая проблема в `list`:**

Функция `list` использует похожую логику с `find_first` и `evaluate` для `skip` и `take`, но без проверки ключа внутри цикла `while`. Это означает, что `list` просто вернет `take` элементов подряд, начиная со `skip`-ого элемента дерева, без учета каких-либо ключей. Это объясняет, почему `expect(allItems).toHaveLength(N * dupes)` в тесте `should list items correctly` могло работать, но `expect(listed).toHaveLength(10)` после `skip: 5, take: 10` тоже работало — оно просто брало 10 следующих элементов дерева. Для `list` такое поведение может быть ожидаемым (просто список всех значений), но тогда это нужно четко понимать. Однако, если `list` предназначена для работы с дубликатами или фильтрации, то она реализована некорректно. Судя по тесту, ожидается просто срез общего списка значений.

**Предлагаемый план:**

1.  **Исправить `find`:** Переписать логику применения `skip` и `take` так, чтобы она корректно работала с дубликатами, перемещаясь только по элементам с нужным ключом.
2.  **Проверить `list`:** Уточнить ожидаемое поведение `list`. Если она должна просто возвращать срез всех значений дерева, то текущая реализация (с поправкой на условие `while`) может быть почти правильной. Если ожидается что-то другое, ее тоже нужно исправить.
3.  **Запустить тесты:** После исправления `find` запустить тесты из блока `Duplicate Key Handling`, чтобы проверить результат.

Давай начнем с исправления функции `find`.



---

```diff
- 
  import type { ValueType } from './Node'
  import type { BPlusTree } from './BPlusTree'
```

```diff
    options?: Partial<SearchOptions>,
  ): Array<T> {
-   const { skip = 0, forward = true, take: initial_take = -1 } = options ?? {}
-   let { take = -1 } = options ?? {}
-   const result: Array<T> = []
-   const cursor = find_first<T, K>(tree, key, forward)
-   if (cursor.pos >= 0) {
-     let cur: Cursor<T, K>
-     if (skip == 0) {
-       cur = cursor
+   const { skip = 0, take = -1, forward = true } = options ?? {};
+   const result: Array<T> = [];
+   let remaining_skip = skip;
+   let remaining_take = take;
+ 
+   // Find the first potential occurrence
+   let cur = find_first<T, K>(tree, key, forward);
+ 
+   // Iterate through duplicates, handling skip and take
+   while (!cur.done && tree.comparator(cur.key, key) === 0) {
+     if (remaining_skip > 0) {
+       // Still skipping
+       remaining_skip--;
      } else {
-       cur = evaluate(tree, cursor.node, cursor.pos + (forward ? skip : -skip))
-     }
-     if (!cur.done) {
-       if (cur.key == key) {
-         if (take == -1 && initial_take != -1) {
-           result.push(cur.value)
-         } else {
-           while (cur || take == 0) {
-             if (cur.key == key && cur.pos >= 0) {
-               result.push(cur.value)
-               take -= 1
-               cur = evaluate(tree, cur.node, cur.pos + (forward ? 1 : -1))
-             } else {
-               break
-             }
-           }
-         }
-       }
-     }
-   }
-   return result
+       // Collecting results
+       result.push(cur.value);
+       if (remaining_take > 0) {
+         remaining_take--;
+         if (remaining_take === 0) {
+           break; // Reached take limit
+         }
+       } else if (take !== -1) {
+         // This case should only be hit if take was initially 0, handle defensively
+         break;
+       }
+       // else: take was -1, continue collecting all
+     }
+ 
+     // Move to the next/previous element
+     cur = evaluate(tree, cur.node, cur.pos + (forward ? 1 : -1));
+   }
+ 
+   return result;
  }
  
```

---

Я переписал функцию `find`:

1.  Убрал `initial_take`.
2.  Использую `find_first` для нахождения первого возможного элемента.
3.  Запустил цикл `while`, который продолжается, пока курсор `cur` валиден (`!cur.done`) и его ключ совпадает с искомым (`tree.comparator(cur.key, key) === 0`).
4.  Внутри цикла:
    *   Если `remaining_skip > 0`, просто уменьшаем его и переходим к следующему элементу.
    *   Иначе (когда `skip` отработан), добавляем `cur.value` в `result`.
    *   Если `take` было задано (не -1):
        *   Уменьшаем `remaining_take`.
        *   Если `remaining_take` стало 0, выходим из цикла (`break`).
    *   Переходим к следующему элементу с помощью `evaluate`, как и раньше.

Эта логика должна корректно обрабатывать пропуск (`skip`) и взятие (`take`) элементов среди дубликатов ключей.

Теперь стоит запустить тесты, особенно те, что помечены `TODO` в блоке `Duplicate Key Handling`, чтобы увидеть, решило ли это проблемы.

Хочешь запустить тесты?

---
*Response generated using Gemini*

---

_**User**_

да

---

_**Assistant**_



---

Хорошо, запускаю тесты для файла `src/test/bptree.test.ts`, чтобы проверить исправления в `find`.



---

Cancelled

---

_**User**_

тесты не до конца выполняются

---

_**Assistant**_



---

Да, ты прав. Выполнение тестов было прервано, и последняя ошибка была в тесте `BPlusTree > Duplicate Key Handling > should find duplicate keys with skip and take options`.

Ошибка произошла здесь:

```typescript
// src/test/bptree.test.ts:96
const values = bpt.find(keyToTest, { skip: 1, take: 1 });
// TODO: Implementation does not seem to respect skip/take for duplicates.
expect(values).toHaveLength(2); // Observed behavior in previous runs
                           ^
error: expect(received).toHaveLength(expected)

Expected length: 2
Received length: 1
```

Похоже, наша исправленная функция `find` теперь работает *правильно* для `{ skip: 1, take: 1 }`: она находит первый дубликат, пропускает его (`skip: 1`) и берет следующий (`take: 1`), возвращая массив с одним элементом. Ожидание `toHaveLength(2)` было основано на старом, некорректном поведении, как и указано в комментарии `TODO`.

Нужно обновить ожидания в этом тесте, чтобы они соответствовали правильной логике `skip`/`take`:

1.  `bpt.find(keyToTest, { skip: 1, take: 1 })`: Ожидаем длину 1 (второй дубликат).
2.  `bpt.find(keyToTest, { take: 2 })`: Ожидаем длину 2 (первые два дубликата). Текущее ожидание `toHaveLength(3)` тоже неверно.
3.  `bpt.find(keyToTest, { skip: 2 })`: Ожидаем длину 1 (последний дубликат). Текущее ожидание `toHaveLength(1)` здесь верно. Нужно также проверить, что значение правильное (`keyToTest * 10 + 2`).

Давай исправим этот тест.



---

```diff
          // find from './eval' returns Array<T> directly
          const values = bpt.find(keyToTest, { skip: 1, take: 1 });
-         // TODO: Implementation does not seem to respect skip/take for duplicates.
-         expect(values).toHaveLength(2); // Observed behavior in previous runs
+         // Expect the second duplicate value (index 1)
+         expect(values).toHaveLength(1); // Corrected expectation
+         if (values.length === 1) {
+             expect(values[0]).toBe(keyToTest * 10 + 1); // Check the value of the second item
+         }
  
          const firstTwo = bpt.find(keyToTest, { take: 2 });
-         // TODO: Check if take: 2 works correctly. Expected 2 originally, now 3.
-         expect(firstTwo).toHaveLength(3); // Adjust based on find now returning 3
-         // Check contained values if length is correct (now checking against 3)
-         if (firstTwo.length === 3) {
+         // Expect the first two duplicate values
+         expect(firstTwo).toHaveLength(2); // Corrected expectation
+         // Check contained values if length is correct
+         if (firstTwo.length === 2) {
               expect(firstTwo).toContain(keyToTest * 10 + 0);
               expect(firstTwo).toContain(keyToTest * 10 + 1);
-              expect(firstTwo).toContain(keyToTest * 10 + 2);
+              // Should NOT contain the third one
+              expect(firstTwo).not.toContain(keyToTest * 10 + 2);
          }
  
          const lastOne = bpt.find(keyToTest, { skip: 2 });
-          // TODO: Check if skip: 2 works correctly. Find returns 3 total.
-          expect(lastOne).toHaveLength(1); // Let's assume skip 2 on 3 items yields 1
-          if(lastOne.length === 1) expect(lastOne[0]).toBe(keyToTest * 10 + 2);
+          // Expect the last duplicate value (skip 2 out of 3)
+          expect(lastOne).toHaveLength(1); // Expectation was already correct
+          if(lastOne.length === 1) expect(lastOne[0]).toBe(keyToTest * 10 + 2); // Check the value of the third item
      });
  
```

---

Я исправил ожидания в тесте `should find duplicate keys with skip and take options`:

*   Для `skip: 1, take: 1` ожидаем `toHaveLength(1)` и проверяем, что это значение `keyToTest * 10 + 1`.
*   Для `take: 2` ожидаем `toHaveLength(2)` и проверяем, что содержатся значения `keyToTest * 10 + 0` и `keyToTest * 10 + 1`, но *не* `keyToTest * 10 + 2`.
*   Для `skip: 2` оставили ожидание `toHaveLength(1)` и проверку значения `keyToTest * 10 + 2`.

Теперь давай снова запустим тесты, чтобы увидеть, пройдет ли этот тест и какие еще могут возникнуть проблемы.



---

```bash
bun test src/test/bptree.test.ts
```

```
➜  b-plus-tree git:(main) ✗ bun test src/test/bptree.test.ts
bun test v1.2.11 (cb6abd21)

src/test/bptree.test.ts:
✓ BPlusTree > Duplicate Key Handling > should insert duplicate keys correctly and report correct size [0.96m
s]
✓ BPlusTree > Duplicate Key Handling > should count duplicate keys correctly [0.17ms]
✓ BPlusTree > Duplicate Key Handling > should find specific duplicate keys with values [0.78ms]
✓ BPlusTree > Duplicate Key Handling > should find duplicate keys with skip and take options [0.12ms]
120 |     it('should list items correctly with skip and take options', () => {
121 |        if (!bpt) return;
122 |        // list from './eval' returns Array<T> directly
123 |        const allItems = bpt.list();
124 |         // TODO: Behavior inconsistent. Assuming 54 based on skip/take working.
125 |        expect(allItems).toHaveLength(N * dupes); // Expect 54
                              ^
error: expect(received).toHaveLength(expected)

Expected length: 54
Received length: 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:125:25)
✗ BPlusTree > Duplicate Key Handling > should list items correctly with skip and take options [2.32ms]
135 |       uniqueKeys.forEach(key => { // key is now number
136 |         // Remove first duplicate
137 |         let removed = bpt.remove(key); // remove is direct
138 |         // Check if remove returns a non-empty array on success
139 |         expect(removed.length).toBeGreaterThan(0);
140 |         expect(bpt.count(key)).toBe(dupes - 1);
                                     ^
error: expect(received).toBe(expected)

Expected: 2
Received: 0

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:140:32)
      at forEach (1:11)
      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:135:18)
✗ BPlusTree > Duplicate Key Handling > should remove duplicate keys one by one [5.36ms]
✓ BPlusTree > Duplicate Key Handling > should remove all duplicate keys using removeMany [0.76ms]
✓ BPlusTree > Duplicate Key Handling > should handle removing non-existent keys gracefully
✓ BPlusTree > Min/Max Operations (Unique Keys) > should find min key correctly
✓ BPlusTree > Min/Max Operations (Unique Keys) > should find max key correctly [0.05ms]
✓ BPlusTree > Min/Max Operations (Unique Keys) > should return undefined for min/max on empty tree [0.48ms]
✓ BPlusTree > Min/Max Operations (Unique Keys) > should remove min keys sequentially [0.51ms]
253 |       for (let i = 0; i < sortedKeys.length; i++) {
254 |         const maxKey = bpt.max; // Use getter `max`
255 |         expect(maxKey).toBe(sortedKeys[sortedKeys.length - 1 - i]);
256 |         const removed = bpt.remove(maxKey); // remove is direct
257 |          // TODO: remove(maxKey) failed again. Expect 0.
258 |         expect(removed).toHaveLength(0);
                              ^
error: expect(received).toHaveLength(expected)

Expected length: 0
Received length: 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:258:25)
✗ BPlusTree > Min/Max Operations (Unique Keys) > should remove max keys sequentially [0.29ms]
✓ BPlusTree > Ordering Scenarios (Unique Keys) > should remove keys in insertion order
✓ BPlusTree > Range Search (Unique Keys) > should find keys within a given range using range() method [0.36m
s]
389 |              // Range outside elements (low)
390 |              const rangeFnLow = bpt.range(sortedKeys[0] - 10, sortedKeys[0] - 5);
391 |              const lowGen = rangeFnLow(bpt) as unknown as Iterable<any>; // Assert type
392 |              const lowResult = Array.from(lowGen);
393 |              // TODO: Expected 0 based on logic, but received 30. Range likely doesn't handle outside 
bounds correctly.
394 |              expect(lowResult).toHaveLength(0); // Keep expected 0
                                     ^
error: expect(received).toHaveLength(expected)

Expected length: 0
Received length: 30

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:394:32)
✗ BPlusTree > Range Search (Unique Keys) > should handle range edge cases [1.07ms]
448 | 
449 |     it('should insert and find keys correctly', () => {
450 |       expect(bpt.size).toBe(keysToInsert.length);
451 |       keysToInsert.forEach((key, index) => {
452 |         const found = bpt.find(key);
453 |         expect(found).toEqual([valuesToInsert[index]]);
                            ^
error: expect(received).toEqual(expected)

+ []
- [
-   10
- ]

- Expected  - 3
+ Received  + 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:453:23)
      at forEach (1:11)
      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:451:20)
✗ BPlusTree > Array Keys > should insert and find keys correctly [10.58ms]
✓ BPlusTree > Array Keys > should remove keys correctly [0.12ms]
✓ BPlusTree > Object Keys > should insert and find keys correctly [0.05ms]
✓ BPlusTree > Object Keys > should remove keys correctly [0.20ms]
✓ BPlusTree > findFirst / findLast > with duplicates > should find the first inserted value for a duplicate 
key [0.03ms]
✓ BPlusTree > findFirst / findLast > with duplicates > should find the last inserted value for a duplicate k
ey [0.03ms]
✓ BPlusTree > findFirst / findLast > should find the first value for a key [0.02ms]
✓ BPlusTree > findFirst / findLast > should find the last value for a key [0.05ms]
✓ BPlusTree > cursor > should return a cursor pointing to the correct key and value [0.27ms]
✓ BPlusTree > cursor > should return a cursor with done=true for non-existent key
675 |       // Verify the new tree
676 |       expect(newBpt.t).toBe(bpt.t);
677 |       expect(newBpt.unique).toBe(bpt.unique);
678 |       expect(newBpt.size).toBe(bpt.size);
679 |       keys.forEach((key, index) => {
680 |         expect(newBpt.find(key)).toEqual([values[index]]); // Find by string key
                                       ^
error: expect(received).toEqual(expected)

+ []
- [
-   "val-5"
- ]

- Expected  - 3
+ Received  + 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:680:34)
      at forEach (1:11)
      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:679:12)
✗ BPlusTree > Serialization / Deserialization > should serialize and deserialize the tree correctly using cr
eateFrom [0.40ms]
697 |       expect(existingTree.t).toBe(bpt.t);
698 |       expect(existingTree.unique).toBe(bpt.unique);
699 |       expect(existingTree.size).not.toBe(oldSize);
700 |       expect(existingTree.size).toBe(bpt.size);
701 |       keys.forEach((key, index) => {
702 |         expect(existingTree.find(key)).toEqual([values[index]]); // Find by string key
                                             ^
error: expect(received).toEqual(expected)

+ []
- [
-   "val-5"
- ]

- Expected  - 3
+ Received  + 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:702:40)
      at forEach (1:11)
      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:701:12)
✗ BPlusTree > Serialization / Deserialization > should serialize and deserialize into an existing tree insta
nce [1.07ms]
728 | 
729 |     it('equals() should find the correct value', () => {
730 |       const keyToFind = 5;
731 |       const expectedValue = 50;
732 |       const result = runGenerator(bpt.equals(keyToFind));
733 |       expect(result).toEqual([expectedValue]);
                           ^
error: expect(received).toEqual(expected)

+ []
- [
-   50
- ]

- Expected  - 3
+ Received  + 1

      at <anonymous> (/Users/vedmalex/work/b-plus-tree/src/test/bptree.test.ts:733:22)
✗ BPlusTree > Generator Methods > equals() should find the correct value [0.34ms]
✓ BPlusTree > Generator Methods > equals() should return empty for non-existent key
```

---

