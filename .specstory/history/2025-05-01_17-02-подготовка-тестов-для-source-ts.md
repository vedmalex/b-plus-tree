<!-- Generated by SpecStory -->

# Подготовка тестов для source.ts (2025-05-01 20:02:43)

_**User**_


давай подготовим разнообразные тесты для @source.ts 

---

_**Assistant**_



---

Хорошо, давай создадим тесты для `src/source.ts`. Я создам файл `src/source.test.ts` и начну добавлять тесты для различных функций, используя `bun:test`.

Сначала я создам базовую структуру файла и добавлю несколько вспомогательных функций для создания тестовых деревьев. Затем я добавлю тесты для `sourceEach`.

```typescript
// src/source.test.ts
import { describe, test, expect, beforeEach } from 'bun:test'
import { BPlusTree } from './BPlusTree' // Assuming BPlusTree is exported from here
import {
  sourceEach,
  sourceEq,
  sourceEqNulls,
  sourceGt,
  sourceGte,
  sourceIn,
  sourceLt,
  sourceLte,
  sourceRange
} from './source'
import type { Cursor } from './eval' // Assuming Cursor type is here
import type { ValueType } from './Node' // Assuming ValueType is here

// Helper to collect results from a generator
const collect = <T, K extends ValueType>(generator: Generator<Cursor<T, K>, void>): Cursor<T, K>[] => {
    const results: Cursor<T, K>[] = [];
    for (const item of generator) {
        // Clone cursor to avoid issues with mutation if the underlying implementation reuses objects
        results.push({ ...item });
    }
    return results;
};

// Helper to simplify tree creation for tests
const createTestTree = <T, K extends ValueType>(entries: [K, T][], order = 3): BPlusTree<T, K> => {
    // Assuming BPlusTree has a constructor that accepts order and comparator
    // And an insert method
    const tree = new BPlusTree<T, K>(order, (a, b) => {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    });
    for (const [key, value] of entries) {
        tree.insert(key, value);
    }
    return tree;
};

describe('B+ Tree Source Generators', () => {
    let tree: BPlusTree<string, number>;
    let emptyTree: BPlusTree<string, number>;

    beforeEach(() => {
        // Create a sample tree for general testing
        tree = createTestTree([
            [10, 'ten'],
            [20, 'twenty'],
            [5, 'five'],
            [15, 'fifteen'],
            [25, 'twenty-five'],
            [30, 'thirty'],
            [1, 'one']
        ]);
        // Create an empty tree for edge cases
        emptyTree = createTestTree([]);
    });

    describe('sourceEach', () => {
        test('iterates forward through all elements', () => {
            const generator = sourceEach<string, number>(true)(tree);
            const results = collect(generator);
            expect(results.map(r => r.key)).toEqual([1, 5, 10, 15, 20, 25, 30]);
            expect(results.map(r => r.value)).toEqual(['one', 'five', 'ten', 'fifteen', 'twenty', 'twenty-five', 'thirty']);
            expect(results.every(r => !r.done)).toBe(true);
        });

        test('iterates backward through all elements', () => {
            const generator = sourceEach<string, number>(false)(tree);
            const results = collect(generator);
             // Note: The current find_last_cursor_equivalent is a placeholder
             // and might not yield the correct *absolute last* element if duplicates of max exist.
             // This test assumes it finds the node with the max key and iterates backward from its last element.
             // Depending on the exact tree structure and find_last_cursor_equivalent logic,
             // the order might differ slightly if find_last isn't precise.
             // Let's assume the simple implementation for now.
            expect(results.map(r => r.key)).toEqual([30, 25, 20, 15, 10, 5, 1]);
            expect(results.map(r => r.value)).toEqual(['thirty', 'twenty-five', 'twenty', 'fifteen', 'ten', 'five', 'one']);
            expect(results.every(r => !r.done)).toBe(true);
        });

        test('handles empty tree for forward iteration', () => {
            const generator = sourceEach<string, number>(true)(emptyTree);
            const results = collect(generator);
            expect(results).toEqual([]);
        });

        test('handles empty tree for backward iteration', () => {
            const generator = sourceEach<string, number>(false)(emptyTree);
            const results = collect(generator);
            expect(results).toEqual([]);
        });

        test('handles tree with one element (forward)', () => {
            const singleItemTree = createTestTree([[10, 'ten']]);
            const generator = sourceEach<string, number>(true)(singleItemTree);
            const results = collect(generator);
            expect(results.map(r => r.key)).toEqual([10]);
            expect(results.map(r => r.value)).toEqual(['ten']);
        });

         test('handles tree with one element (backward)', () => {
            const singleItemTree = createTestTree([[10, 'ten']]);
            const generator = sourceEach<string, number>(false)(singleItemTree);
            const results = collect(generator);
            expect(results.map(r => r.key)).toEqual([10]);
            expect(results.map(r => r.value)).toEqual(['ten']);
        });
    });

    // Add tests for other source functions here...
    // describe('sourceEq', () => { ... });
    // describe('sourceGt', () => { ... });
    // ... and so on
});
```

Я создаю новый файл `src/source.test.ts` с этим содержимым. Этот код включает базовую настройку с `beforeEach` для создания тестовых деревьев и первые тесты для `sourceEach` (прямой и обратный обход, пустые и одноэлементные деревья). Также добавлены вспомогательные функции `collect` и `createTestTree`.

Далее я могу добавить тесты для `sourceEq` и других функций.



---

